/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { CategorySeries } from "./CategorySeries";
import { IIsCategoryBased_$type } from "./IIsCategoryBased";
import { IHasSingleValueCategory_$type } from "./IHasSingleValueCategory";
import { IHasCategoryTrendline_$type } from "./IHasCategoryTrendline";
import { ITrendLineSeries_$type } from "./ITrendLineSeries";
import { IAnchoredCategorySeriesInteractionManager_$type } from "./IAnchoredCategorySeriesInteractionManager";
import { DVContainer } from "igniteui-react-core";
import { Point_$type, enumGetBox, typeCast, runOn, delegateCombine, markType, markDep } from "igniteui-react-core";
import { DependencyProperty } from "igniteui-react-core";
import { Series } from "./Series";
import { TrendLineType_$type } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { PenLineCap_$type } from "igniteui-react-core";
import { DoubleCollection } from "igniteui-react-core";
import { CategoryFrame } from "./CategoryFrame";
import { ICategoryScaler_$type } from "./ICategoryScaler";
import { IScaler_$type } from "./IScaler";
import { CategorySeriesView } from "./CategorySeriesView";
import { CategorySeriesMarkerCollisionAvoidance_$type } from "./CategorySeriesMarkerCollisionAvoidance";
import { ConsolidatedItemHitTestBehavior_$type } from "./ConsolidatedItemHitTestBehavior";
import { CategoryFramePreparer } from "./CategoryFramePreparer";
import { DataLegendSeriesValueInfo } from "igniteui-react-core";
import { DataLegendSeriesContext } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { Rect } from "igniteui-react-core";
import { ISortingAxis_$type } from "./ISortingAxis";
import { IFastItemsSource_$type } from "igniteui-react-core";
import { NumericAxisBase } from "./NumericAxisBase";
import { CategoryBucketCalculator } from "./CategoryBucketCalculator";
import { AxisRange } from "./AxisRange";
import { NumericYAxis } from "./NumericYAxis";
import { ScalerParams } from "./ScalerParams";
import { SeriesLayerPropertyOverlay } from "./SeriesLayerPropertyOverlay";
import { CategoryMarkerManager } from "./CategoryMarkerManager";
import { CollisionAvoider } from "./CollisionAvoider";
import { NonCollisionAvoider } from "./NonCollisionAvoider";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { PropertyMetadata } from "igniteui-react-core";
import { truncate, isNaN_, isInfinity } from "igniteui-react-core";
import { CategoryTrendLineManagerFactory } from "./CategoryTrendLineManagerFactory";
/**
 * @hidden
 */
export let AnchoredCategorySeries = /*@__PURE__*/ (() => {
    class AnchoredCategorySeries extends CategorySeries {
        get y0() {
            if (this.yz == null) {
                this.yz = DVContainer.instance.createInstance(IAnchoredCategorySeriesInteractionManager_$type, () => this.dg.n);
            }
            return this.yz;
        }
        getHostReferenceValue() {
            return this.id();
        }
        lj() {
            return AnchoredCategorySeries.$$p[5];
        }
        ci() {
            let a = new AnchoredCategorySeriesView(this);
            return a;
        }
        px(a) {
            super.px(a);
            this.yv = a;
        }
        constructor() {
            super();
            this.yz = null;
            this.y4 = false;
            this.y1 = null;
            this.yw = null;
            this.zb = null;
            this.za = null;
            this.y3 = true;
            this.y5 = 0;
            this.y6 = 0;
            this.w7 = new CategoryFramePreparer(1, this, this.xb, this, this, this.xb.cu);
        }
        j5(a, b) {
            let c = this.mh(b);
            if (c == AnchoredCategorySeries.$$p[5]) {
                return this.j6(a, b, this.zl);
            }
            if (c == AnchoredCategorySeries.$$p[1]) {
                return this.j6(a, b, this.zd);
            }
            return super.j5(a, b);
        }
        li(a) {
            let b = this.mh(a);
            if (b == AnchoredCategorySeries.$$p[5]) {
                return this.zl;
            }
            if (b == AnchoredCategorySeries.$$p[1]) {
                return this.zd;
            }
            return super.li(a);
        }
        get valueColumn() {
            return this.y1;
        }
        set valueColumn(a) {
            if (this.y1 != a) {
                let b = this.y1;
                this.y1 = a;
                if (!this.y4) {
                    this.raisePropertyChanged("ValueColumn", b, this.y1);
                }
            }
        }
        getDataLegendSeriesContextAt(a, b) {
            let c = new DataLegendSeriesValueInfo();
            c.a = 0;
            c.l = this.il({ $type: Point_$type, x: a, y: b }, false, false);
            c.r = this.zl != null ? this.zl : "Value";
            c.q = "Value";
            c.s = this.zh != null ? this.zh : "V:";
            c.t = this.zj != null ? this.zj : "";
            let d = new DataLegendSeriesContext();
            d.e = ((() => {
                let $ret = new List$1(DataLegendSeriesValueInfo.$, 0);
                $ret.add(c);
                return $ret;
            })());
            d.h = this.lh();
            return d;
        }
        get z8() {
            return this.c(AnchoredCategorySeries.zu);
        }
        set z8(a) {
            this.h(AnchoredCategorySeries.zu, a);
        }
        fx(a) {
            let b = new Rect(0, 0, 0, 1, 1);
            let c = this.fetchXAxis();
            let d = this.fetchYAxis();
            let e = this.u3(this.cl);
            let f = c != null ? this.w7.r(typeCast(ICategoryScaler_$type, c), b, b, e) : 0;
            return this.y0.c$a(this, this.valueColumn, c, d, f, a);
        }
        ys(a, b, c) {
            if (b < a || a < 0 || a > this.valueColumn.count || b < 0 || b > this.valueColumn.count || c == null) {
                return null;
            }
            let d = new Array((b - a) + 1);
            let e = c.cn;
            let f = null;
            if (e) {
                f = c.i$b;
            }
            for (let g = a; g <= b; g++) {
                let h = g;
                if (e) {
                    h = f._inner[h];
                }
                d[g - a] = this.dd.item(g);
            }
            return d;
        }
        p5(a, b, c, d) {
            super.p5(a, b, c, d);
            if (this.yv.c6 && this.yv.c5.g$b(a, b, c, d)) {
                let e = false;
                if (b == "FastItemsSource") {
                    e = this.f0 && c != null;
                }
                this.qm(e);
                this.ph();
            }
            switch (b) {
                case AnchoredCategorySeries.$$p[3]:
                case AnchoredCategorySeries.$$p[4]:
                    this.pb();
                    break;
                case "FastItemsSource":
                    if (typeCast(IFastItemsSource_$type, c) != null) {
                        c.deregisterColumn(this.valueColumn);
                        this.valueColumn = null;
                    }
                    if (typeCast(IFastItemsSource_$type, d) != null) {
                        this.valueColumn = this.da(this.zl);
                    }
                    let f = typeCast(NumericAxisBase.$, this.fetchYAxis());
                    if (f != null && !f.c1()) {
                        this.yv.cu.g(this.hu);
                        this.qm(this.f0 && c != null);
                    }
                    break;
                case AnchoredCategorySeries.$$p[5]:
                    if (this.dd != null) {
                        this.dd.deregisterColumn(this.valueColumn);
                        this.valueColumn = this.da(this.zl);
                    }
                    this.zb = this.zl;
                    break;
                case AnchoredCategorySeries.$$p[1]:
                    this.za = this.zd;
                    this.qm(true);
                    break;
                case "ValueColumn":
                    if (this.yv.c6) {
                        this.yv.c5.g$i();
                    }
                    let g = typeCast(NumericAxisBase.$, this.fetchYAxis());
                    if (g != null && !g.c1()) {
                        this.yv.cu.g(this.hu);
                        this.qm(this.f0 && this.dv);
                    }
                    this.zt();
                    this.rg();
                    break;
                case "TrendLineBrush":
                    this.qb(b);
                    break;
                case "ErrorBarSettings":
                    this.qm(false);
                    break;
                case "TrendLineType":
                    this.ph();
                    break;
                case AnchoredCategorySeries.$$p[2]:
                    this.qm(false);
                    break;
            }
        }
        aq(a) {
            if (this.valueColumn == null || this.valueColumn.count == 0) {
                return null;
            }
            if (a == this.fetchXAxis()) {
                return new AxisRange(0, this.valueColumn.count - 1);
            }
            if (a == this.fetchYAxis()) {
                return new AxisRange(this.valueColumn.minimum, this.valueColumn.maximum);
            }
            return null;
        }
        oc(a, b, c, d) {
            switch (a) {
                case 4:
                case 1:
                case 0:
                    this.yv.cu.g(this.hu);
                    break;
            }
            if (this.yv.c6) {
                this.yv.c5.g$e(a, b, c, d);
            }
            this.zt();
            this.rg();
            if (a == 0 || a == 2 || a == 3 || a == 4) {
                this.y3 = true;
            }
            else if (a == 1) {
                for (let e = b; e < b + c; e++) {
                    this.y5 += this.valueColumn.item(e);
                }
                this.y6 = this.y5 / this.valueColumn.count;
            }
        }
        x2() {
            return this.y7(this.xb);
        }
        y7(a) {
            let b = 0;
            let c = a.by;
            let d = a.bx;
            let e = this.getEffectiveViewport1(a);
            let f = typeCast(NumericYAxis.$, this.fetchYAxis());
            if (!c.isEmpty && !d.isEmpty && f != null) {
                let g = new ScalerParams(0, c, d, f.ch, e);
                if (f.cp) {
                    g.b = this.id();
                }
                b = f.ej(f.l7, g);
            }
            return b;
        }
        zr(a, b, c) {
            let d = this.y7(c);
            if (a.count > 0) {
                let e = d;
                a.add({ $type: Point_$type, x: a._inner[a.count - 1].x, y: e });
                a.add({ $type: Point_$type, x: a._inner[0].x, y: e });
            }
        }
        yt(a, b, c, d) {
            return this.yu(a, b, c, d, false);
        }
        yu(a, b, c, d, e) {
            return CategorySeries.ww(a, b, c, d, e);
        }
        fv() {
            return this.highlightedItemsSource != null || this.zd != null;
        }
        hb() {
            let a = super.hb();
            {
                let b = ((() => {
                    let $ret = new SeriesLayerPropertyOverlay();
                    $ret.ad = "ValueMemberPath";
                    $ret.p = true;
                    $ret.y = "HighlightedValueMemberPath";
                    $ret.q = true;
                    return $ret;
                })());
                b.valueResolving = delegateCombine(b.valueResolving, runOn(this, this.zn));
                a.add(b);
            }
            return a;
        }
        zn(a, b) {
            if (this.zd != null) {
                b.value = this.zd;
                return;
            }
            b.value = this.zl;
        }
        gw(a, b, c) {
            let d = super.gw(a, b, c);
            let e = c;
            if (this.valueColumn == null || this.valueColumn.count == 0 || e.cu.d < 1) {
                d = false;
            }
            return d;
        }
        n7(a, b) {
            super.n7(a, b);
            let c = b;
            c.c0();
            if (c.c6) {
                c.c5.g$d();
            }
        }
        yi(a, b) {
            super.yi(a, b);
            this.w8(b).d(a, b);
        }
        yl(a, b) {
            super.yl(a, b);
            let c = typeCast(AnchoredCategorySeriesView.$, b);
            c.b6 = true;
            if (c.c6) {
                c.c5.g$g(a.q);
            }
            if (this.vr()) {
                CategoryMarkerManager.e(this, a.n, b.cx, this.vt);
                this.yf(b, a);
                b.cp();
            }
            this.zo(a, b);
        }
        ql(a, b, c, d, e) {
            super.ql(a, b, c, d, e);
            let f = this.a2.a$i.item(d);
            let g = f;
            g.cu.g(this.hu);
            f.a3(c);
            if (this.dt(g)) {
                return;
            }
            if (this.yw == null) {
                this.yw = new CategoryFrame(3);
            }
            this.yw.v();
            this.yi(this.yw, g);
            this.yl(this.yw, g);
        }
        zo(a, b) {
        }
        ra() {
            super.ra();
            if (this.index < 0) {
                return;
            }
            this.yv.da();
            if (this.trendLineBrush != null) {
                this.yv.c8();
            }
            else {
                this.yv.c7();
            }
        }
        j9(a, b) {
            if (this.yv.c6 && a == this.yv.c5.g$j) {
                return null;
            }
            return super.j9(a, b);
        }
        get currentCategoryMode() {
            return this.preferredCategoryMode(typeCast(CategoryAxisBase.$, this.w1()));
        }
        get scaler() {
            return typeCast(ICategoryScaler_$type, this.w1());
        }
        get yScaler() {
            return typeCast(IScaler_$type, this.xh());
        }
        get bucketizer() {
            return this.yv.cu;
        }
        get currentMode2Index() {
            return this.x6();
        }
        provideCollisionDetector() {
            if (this.yx == 1) {
                return new CollisionAvoider();
            }
            return NonCollisionAvoider.b;
        }
        get trendlinePreparer() {
            return this.yv.c6 ? this.yv.c5 : null;
        }
        ow(a) {
            super.ow(a);
            if (this.yv.c6) {
                this.a4.exportTrendlineData(this, a, this.yv.c5.g$j);
            }
        }
        j2(a) {
            let b = this.fetchXAxis();
            let c = this.fetchYAxis();
            return this.y0.c$b(this, a, this.x3(this.cl), this.valueColumn, b, c, this.yy == 1, (d) => super.j2(d));
        }
        get mayContainUnknowns() {
            return this.valueColumn == null || this.valueColumn.mayContainUnknowns;
        }
        id() {
            return Series.ie(this.valueColumn, typeCast(ISortingAxis_$type, this.fetchXAxis()));
        }
        get_y9() {
            return 0;
        }
        get y9() {
            return this.get_y9();
        }
        ar(a) {
            if (a.isEmpty && this.c1 != null) {
                a = this.c1.vh;
            }
            if (this.valueColumn == null) {
                return null;
            }
            let b = this.u1(this.cl);
            let c = this.w1();
            let d = new ScalerParams(0, a, this.c1.vw, c.ch, this.getEffectiveViewport());
            let e = (c.em(b.left, d));
            let f = (c.em(b.right, d));
            if (c.ch) {
                let g = e;
                e = f;
                f = g;
            }
            e -= this.y9;
            f += this.y9;
            let h = null;
            if (c.cn) {
                h = c;
                e = h.i$f(e);
                f = h.i$f(f);
            }
            else {
                e = Math.floor(e);
                f = Math.ceil(f);
            }
            if (isNaN_(e) || isNaN_(f)) {
                return null;
            }
            e = Math.max(0, Math.min(this.valueColumn.count - 1, e));
            f = Math.max(0, Math.min(this.valueColumn.count - 1, f));
            let i = 1.7976931348623157E+308;
            let j = -1.7976931348623157E+308;
            if (truncate(e) <= truncate(f)) {
                for (let k = truncate(e); k <= truncate(f); k++) {
                    let l = k;
                    if (h != null) {
                        l = h.i$b._inner[k];
                    }
                    let m = this.valueColumn.item(l);
                    if (this.valueColumn.mayContainUnknowns) {
                        if (isInfinity(m) || isNaN_(m)) {
                            continue;
                        }
                    }
                    i = Math.min(i, m);
                    j = Math.max(j, m);
                }
            }
            let n = new AxisRange(i, j);
            n = this.ap(n, this.xh(), a);
            return n;
        }
        zt() {
            this.h2 = this.valueColumn == null || this.valueColumn.count == 0 ? NaN : this.valueColumn.item(this.valueColumn.count - 1);
        }
        zs() {
            if (this.y3) {
                this.y5 = 0;
                for (let a = 0; a < this.valueColumn.count; a++) {
                    this.y5 += this.valueColumn.item(a);
                }
                this.y6 = this.y5 / this.valueColumn.count;
                this.y3 = false;
            }
        }
        ip(a, b) {
            if (b == null || !b.cj) {
                return NaN;
            }
            let c = this.xh();
            if (b != c) {
                return NaN;
            }
            let d = this.am(a);
            if (c.cp) {
                return d[1];
            }
            else {
                return d[0];
            }
        }
        am(a) {
            let b = NaN;
            switch (a) {
                case 5:
                case 2:
                    b = this.valueColumn.maximum;
                    break;
                case 4:
                case 1:
                    b = this.valueColumn.minimum;
                    break;
                case 6:
                case 3:
                    if (this.y3) {
                        this.zs();
                    }
                    b = this.y6;
                    break;
            }
            let c = this.xh();
            if (c.cp) {
                return [NaN, b];
            }
            else {
                return [b, NaN];
            }
        }
        ux(a) {
            let b = NaN;
            switch (a) {
                case 5:
                case 2:
                    b = this.valueColumn.maximum;
                    break;
                case 4:
                case 1:
                    b = this.valueColumn.minimum;
                    break;
                case 6:
                case 3:
                    if (this.y3) {
                        this.zs();
                    }
                    b = this.y6;
                    break;
            }
            if (isNaN_(b)) {
                return { $type: Point_$type, x: NaN, y: NaN };
            }
            let c = this.xh();
            let d = this.getEffectiveViewport1(this.cl);
            let e = new ScalerParams(0, this.cl.by, this.cl.bx, c.ch, d);
            if (c.cp) {
                e.b = this.id();
            }
            e.c = d;
            if (c.cp) {
                return { $type: Point_$type, x: NaN, y: c.ej(b, e) };
            }
            else {
                return { $type: Point_$type, x: c.ej(b, e), y: NaN };
            }
        }
        uy(a) {
            let b = this.xh();
            let c = this.getEffectiveViewport1(this.cl);
            let d = new ScalerParams(0, this.cl.by, this.cl.bx, b.ch, c);
            if (b.cp) {
                d.b = this.id();
            }
            d.c = c;
            if (b.cp) {
                return { $type: Point_$type, x: NaN, y: b.ej(a[1], d) };
            }
            else {
                return { $type: Point_$type, x: b.ej(a[0], d), y: NaN };
            }
        }
        get useHighMarkerFidelity() {
            return this.xy;
        }
    }
    AnchoredCategorySeries.$t = /*@__PURE__*/ markType(AnchoredCategorySeries, 'AnchoredCategorySeries', CategorySeries.$, [IIsCategoryBased_$type, IHasSingleValueCategory_$type, IHasCategoryTrendline_$type, ITrendLineSeries_$type]);
    AnchoredCategorySeries.zu = /*@__PURE__*/ DependencyProperty.i("ActualTrendLineBrush", Brush.$, AnchoredCategorySeries.$, /*@__PURE__*/ new PropertyMetadata(2, null, (a, b) => a.raisePropertyChanged("ActualTrendLineBrush", b.oldValue, b.newValue)));
    AnchoredCategorySeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, AnchoredCategorySeries, 'raisePropertyChanged', ['ConsolidatedItemHitTestBehavior:yy:zv', [ConsolidatedItemHitTestBehavior_$type, /*@__PURE__*/ enumGetBox(ConsolidatedItemHitTestBehavior_$type, 0)], 'HighlightedValueMemberPath:zd:zw', [2, null], 'MarkerCollisionAvoidance:yx:zx', [CategorySeriesMarkerCollisionAvoidance_$type, /*@__PURE__*/ enumGetBox(CategorySeriesMarkerCollisionAvoidance_$type, 1)], 'ValueMemberAsLegendLabel:zh:z5', [2, null], 'ValueMemberAsLegendUnit:zj:z6', [2, null], 'ValueMemberPath:zl:z7', [2, null], 'TrendLineType::z3', [TrendLineType_$type, /*@__PURE__*/ enumGetBox(TrendLineType_$type, 0)], 'TrendLineThickness::z2', [1, 1.5], 'TrendLinePeriod::z1', [1, 7], 'TrendLineBrush::zy', [Brush.$, null], 'TrendLineZIndex:y8:z4', [1, 1001], 'TrendLineDashArray:z9:zz', [DoubleCollection.$], 'TrendLineDashCap:aaa:z0', [PenLineCap_$type, /*@__PURE__*/ enumGetBox(PenLineCap_$type, 0)]]);
    return AnchoredCategorySeries;
})();
/**
 * @hidden
 */
export let AnchoredCategoryBucketCalculator = /*@__PURE__*/ (() => {
    class AnchoredCategoryBucketCalculator extends CategoryBucketCalculator {
        constructor(a) {
            super(a);
            this.i = null;
            this.h = null;
            this.j = 0;
            this.i = a;
        }
        getBucketWithoutUnknowns(a) {
            let b = this.h;
            let c = this.j;
            let d = a * this.d;
            let e = d + this.d - 1;
            let f = c - 1;
            d = d < f ? d : f;
            e = e < f ? e : f;
            let g = 1.7976931348623157E+308;
            let h = -1.7976931348623157E+308;
            let i = true;
            for (let j = d; j <= e; ++j) {
                let k = b[j];
                g = g < k ? g : k;
                h = h > k ? h : k;
                i = false;
            }
            if (!i) {
                return [0.5 * (d + e), g, h];
            }
            return [0.5 * (d + e), NaN, NaN];
        }
        getBucket(a) {
            let b = this.h;
            let c = this.j;
            let d = a * this.d;
            let e = d + this.d - 1;
            let f = c - 1;
            d = d < f ? d : f;
            e = e < f ? e : f;
            let g = 0;
            let h = 0;
            let i = true;
            for (let j = d; j <= e; ++j) {
                let k = b[j];
                if (!i) {
                    if (!isNaN_(k)) {
                        g = g < k ? g : k;
                        h = h > k ? h : k;
                    }
                }
                else {
                    if (!isNaN_(k)) {
                        g = k;
                        h = k;
                        i = false;
                    }
                }
            }
            if (!i) {
                return [0.5 * (d + e), g, h];
            }
            return [0.5 * (d + e), NaN, NaN];
        }
        cacheValues() {
            this.j = this.i.c3.valueColumn.count;
            this.h = this.i.c3.valueColumn.asArray();
        }
        unCacheValues() {
            this.h = null;
        }
    }
    AnchoredCategoryBucketCalculator.$t = /*@__PURE__*/ markType(AnchoredCategoryBucketCalculator, 'AnchoredCategoryBucketCalculator', CategoryBucketCalculator.$);
    return AnchoredCategoryBucketCalculator;
})();
/**
 * @hidden
 */
export let AnchoredCategorySeriesView = /*@__PURE__*/ (() => {
    class AnchoredCategorySeriesView extends CategorySeriesView {
        constructor(a) {
            super(a);
            this.c3 = null;
            this.c4 = null;
            this.c3 = a;
        }
        get c5() {
            if (this.c4 == null) {
                this.c4 = CategoryTrendLineManagerFactory.a(this.c4, this.e.as(), this.e.ro, this.e, this.e.dg);
            }
            return this.c4;
        }
        set c5(a) {
            this.c4 = a;
        }
        get c6() {
            return this.c4 != null;
        }
        da() {
            this.c3.z8 = null;
        }
        c8() {
            this.c3.z8 = this.c3.trendLineBrush;
        }
        c7() {
            this.c3.z8 = this.c3.tw;
        }
        cv() {
            return new AnchoredCategoryBucketCalculator(this);
        }
        c9() {
            this.cu.cacheValues();
        }
        db() {
            this.cu.unCacheValues();
        }
        dc(a) {
            let b = this.cx.item(a);
            return this.cs(b);
        }
        a7(a, b) {
            if (a.d) {
                if (this.c3.trendLineType != 0 && !b) {
                    let c = this.c5.g$j;
                    c.ad = this.c3.trendLineThickness;
                    c._stroke = this.c3.z8;
                    c.ai = this.c3.z9;
                    c.aj = this.c3.aaa;
                    a.v(c);
                }
            }
            super.a7(a, b);
        }
        getDefaultTooltipTemplate() {
            return this.c3.y0.c$c(this.e, this.c3.zl);
        }
    }
    AnchoredCategorySeriesView.$t = /*@__PURE__*/ markType(AnchoredCategorySeriesView, 'AnchoredCategorySeriesView', CategorySeriesView.$);
    return AnchoredCategorySeriesView;
})();
