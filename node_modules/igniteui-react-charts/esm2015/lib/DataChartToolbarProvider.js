/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, BaseError, typeCast, fromEnum, runOn, delegateCombine, delegateRemove, markType, TypeRegistrar } from "igniteui-react-core";
import { IDataChartToolbarProvider_$type } from "./IDataChartToolbarProvider";
import { ToolActionIconButtonInfo } from "igniteui-react-core";
import { ToolActionIconMenuInfo } from "igniteui-react-core";
import { ToolActionGroupHeaderInfo } from "igniteui-react-core";
import { ToolActionSeparatorInfo } from "igniteui-react-core";
import { ToolActionLabelInfo } from "igniteui-react-core";
import { ToolActionCheckboxInfo } from "igniteui-react-core";
import { DeviceUtils } from "igniteui-react-core";
import { ToolActionRadioInfo } from "igniteui-react-core";
import { ToolCommandArgument } from "igniteui-react-core";
import { AutomaticSeriesRequest } from "./AutomaticSeriesRequest";
import { Axis } from "./Axis";
import { XamDataChart } from "./XamDataChart";
import { FastIterationDictionary$2 } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
import { CaptureImageSettings } from "igniteui-react-core";
/**
 * @hidden
 */
export let DataChartToolbarProvider = /*@__PURE__*/ (() => {
    class DataChartToolbarProvider extends Base {
        constructor() {
            super(...arguments);
            this._container = null;
            this.j = null;
            this.h = null;
            this.f = null;
            this.l = null;
            this.m = new FastIterationDictionary$2(Axis.$, Brush.$, 0);
        }
        get container() {
            return this._container;
        }
        set container(a) {
            this._container = a;
        }
        get k() {
            if (TypeRegistrar.isRegistered("HorizontalAnchoredCategorySeriesProxy")) {
                return TypeRegistrar.create("HorizontalAnchoredCategorySeriesProxy");
            }
            else {
                throw new BaseError(1, "category series module is not loaded, but is required.");
            }
        }
        get p() {
            return (TypeRegistrar.isRegistered("HorizontalAnchoredCategorySeriesProxy"));
        }
        get i() {
            if (TypeRegistrar.isRegistered("FinancialPriceSeriesProxy")) {
                return TypeRegistrar.create("FinancialPriceSeriesProxy");
            }
            else {
                throw new BaseError(1, "category series module is not loaded, but is required.");
            }
        }
        get o() {
            return (TypeRegistrar.isRegistered("HorizontalAnchoredCategorySeriesProxy"));
        }
        get g() {
            if (this.f == null) {
                if (TypeRegistrar.isRegistered("AnnotationLayerProxy")) {
                    this.f = TypeRegistrar.create("AnnotationLayerProxy");
                    this.f.container = this.container;
                }
                else {
                    throw new BaseError(1, "annotation layer module is not loaded, but is required.");
                }
            }
            return this.f;
        }
        get n() {
            return (TypeRegistrar.isRegistered("AnnotationLayerProxy"));
        }
        getDesiredToolbarActions() {
            let a = new ToolActionIconButtonInfo();
            a.name = "ZoomReset";
            a.iconName = "reset";
            a.iconCollectionName = "ChartToolbarIcons";
            a.title = "Reset";
            let b = new ToolActionIconMenuInfo();
            b.name = "ZoomMenu";
            b.iconName = "zoomin";
            b.iconCollectionName = "ChartToolbarIcons";
            b.actions = this.e();
            let c = new ToolActionGroupHeaderInfo();
            c.name = "AnalyzeHeader";
            c.title = "Analyze";
            let d = new ToolActionSeparatorInfo();
            d.name = "AnalyzeHeaderSeparator";
            d.isGroupHeaderSeparator = true;
            let e = new ToolActionLabelInfo();
            e.name = "LinesMenu";
            e.title = "Lines";
            e.iconName = "analyze-lines";
            e.iconCollectionName = "ChartToolbarIcons";
            e.actions = this.a();
            let f = new ToolActionSeparatorInfo();
            f.name = "LinesMenuSeparator";
            let g = new ToolActionLabelInfo();
            g.name = "TrendsMenu";
            g.title = "Trends";
            g.iconName = "analyze-trends";
            g.iconCollectionName = "ChartToolbarIcons";
            g.actions = this.c();
            let h = new ToolActionGroupHeaderInfo();
            h.name = "HelpersHeader";
            h.title = "Helpers";
            let i = new ToolActionSeparatorInfo();
            i.name = "HelpersHeaderSeparator";
            i.isGroupHeaderSeparator = true;
            let j = new ToolActionCheckboxInfo();
            j.name = "SeriesAvg";
            j.title = "Series Average";
            j.iconName = "analyze-seriesavg";
            j.iconCollectionName = "ChartToolbarIcons";
            let k = new ToolActionSeparatorInfo();
            k.name = "SeriesAvgSeparator";
            let l = new ToolActionLabelInfo();
            l.name = "ValueLabelsMenu";
            l.title = "Value Labels";
            l.iconName = "analyze-valuelabels";
            l.iconCollectionName = "ChartToolbarIcons";
            l.actions = this.d();
            let m = new ToolActionSeparatorInfo();
            m.name = "HelpersSectionSeparator";
            m.size = DeviceUtils.g(10);
            let n = new ToolActionCheckboxInfo();
            n.name = "ShowGridlines";
            n.title = "Grid";
            n.iconName = "analyze-grid";
            n.iconCollectionName = "ChartToolbarIcons";
            let o = new ToolActionSeparatorInfo();
            o.name = "GridSeparator";
            let p = new ToolActionCheckboxInfo();
            p.name = "ShowCrosshairs";
            p.title = "Crosshairs";
            p.iconName = "analyze-crosshairs";
            p.iconCollectionName = "ChartToolbarIcons";
            let q = new ToolActionIconMenuInfo();
            q.name = "AnalyzeMenu";
            q.iconName = "analyze";
            q.iconCollectionName = "ChartToolbarIcons";
            q.actions = [c, d, e, f, g, h, i, j, k, l, m, n, o, p];
            let r = new ToolActionGroupHeaderInfo();
            r.name = "CopyHeader";
            r.title = "Copy...";
            let s = new ToolActionLabelInfo();
            s.name = "CopyAsImage";
            s.title = "As Image";
            s.iconName = "copy-image";
            s.iconCollectionName = "ChartToolbarIcons";
            s.closeOnExecute = true;
            let t = new ToolActionLabelInfo();
            t.name = "CopyAsTable";
            t.title = "Table Data";
            t.iconName = "copy-table";
            t.iconCollectionName = "ChartToolbarIcons";
            let u = new ToolActionIconMenuInfo();
            u.name = "CopyMenu";
            u.iconName = "copy";
            u.iconCollectionName = "ChartToolbarIcons";
            u.actions = [r, s];
            return [a, b, ((() => {
                    let $ret = new ToolActionSeparatorInfo();
                    $ret.name = "ZoomMenuSeparator";
                    return $ret;
                })()), q, ((() => {
                    let $ret = new ToolActionSeparatorInfo();
                    $ret.name = "AnalyzeMenuSeparator";
                    return $ret;
                })()), u];
        }
        e() {
            let a = new ToolActionGroupHeaderInfo();
            a.name = "ZoomHeader";
            a.title = "Zoom";
            let b = new ToolActionLabelInfo();
            b.name = "ZoomIn";
            b.iconName = "zoomin";
            b.iconCollectionName = "ChartToolbarIcons";
            b.title = "Zoom In";
            let c = new ToolActionLabelInfo();
            c.name = "ZoomOut";
            c.iconName = "zoomout";
            c.iconCollectionName = "ChartToolbarIcons";
            c.title = "Zoom Out";
            return [a, b, c];
        }
        a() {
            let a = new ToolActionGroupHeaderInfo();
            a.name = "LinesHeader";
            a.title = "Lines";
            let b = new ToolActionSeparatorInfo();
            b.isGroupHeaderSeparator = true;
            let c = new ToolActionCheckboxInfo();
            c.name = "MaxValue";
            c.title = "Max value";
            c.iconName = "analyze-lines-maxvalue";
            c.iconCollectionName = "ChartToolbarIcons";
            let d = new ToolActionCheckboxInfo();
            d.name = "MinValue";
            d.title = "Min value";
            d.iconName = "analyze-lines-minvalue";
            d.iconCollectionName = "ChartToolbarIcons";
            let e = new ToolActionCheckboxInfo();
            e.name = "Average";
            e.title = "Average";
            e.iconName = "analyze-seriesavg";
            e.iconCollectionName = "ChartToolbarIcons";
            return [a, b, c, d, e];
        }
        c() {
            let a = new ToolActionGroupHeaderInfo();
            a.name = "TrendsHeader";
            a.title = "Trends";
            let b = new ToolActionSeparatorInfo();
            b.isGroupHeaderSeparator = true;
            let c = new ToolActionRadioInfo();
            c.name = "Exponential";
            c.title = "Exponential";
            c.iconName = "analyze-trends-exp";
            c.iconCollectionName = "ChartToolbarIcons";
            c.channel = "trends";
            let d = new ToolActionRadioInfo();
            d.name = "Linear";
            d.title = "Linear";
            d.iconName = "analyze-trends-trendline";
            d.iconCollectionName = "ChartToolbarIcons";
            d.channel = "trends";
            let e = new ToolActionRadioInfo();
            e.name = "Logarithmic";
            e.title = "Logarithmic";
            e.iconName = "analyze-trends-log";
            e.iconCollectionName = "ChartToolbarIcons";
            e.channel = "trends";
            let f = new ToolActionRadioInfo();
            f.name = "NoTrends";
            f.title = "None";
            f.channel = "trends";
            f.iconName = "ig-NoIcon";
            return [a, b, c, d, e, f];
        }
        b() {
            let a = new ToolActionGroupHeaderInfo();
            a.name = "TimePeriodHighlightHeader";
            a.title = "TIME HIGHLIGHT";
            let b = new ToolActionSeparatorInfo();
            b.isGroupHeaderSeparator = true;
            let c = new ToolActionRadioInfo();
            c.name = "Quarters";
            c.title = "Quarters";
            c.channel = "time";
            let d = new ToolActionRadioInfo();
            d.name = "Seasons";
            d.title = "Seasons";
            d.channel = "time";
            let e = new ToolActionRadioInfo();
            e.name = "Weekends";
            e.title = "Weekends";
            e.channel = "time";
            let f = new ToolActionRadioInfo();
            f.name = "WorkDays";
            f.title = "Work days";
            f.channel = "time";
            return [a, b, c, d, e, f];
        }
        d() {
            let a = new ToolActionGroupHeaderInfo();
            a.name = "ValueLabelsHeader";
            a.title = "Value Labels";
            let b = new ToolActionSeparatorInfo();
            b.isGroupHeaderSeparator = true;
            let c = new ToolActionCheckboxInfo();
            c.name = "ShowValueLabels";
            c.title = "Show Value Labels";
            c.iconName = "analyze-valuelabels";
            c.iconCollectionName = "ChartToolbarIcons";
            let d = new ToolActionCheckboxInfo();
            d.name = "ShowLastValueLabel";
            d.title = "Show Last Value Label";
            d.iconName = "analyze-valuelabels-showlast";
            d.iconCollectionName = "ChartToolbarIcons";
            return [a, b, c, d];
        }
        onToolCommandExecuting(a, b) {
            switch (b.commandId) {
                case "ZoomReset":
                    this.ah(a, b);
                    break;
                case "ZoomIn":
                    this.af(a, b);
                    break;
                case "ZoomOut":
                    this.ag(a, b);
                    break;
                case "ShowCrosshairs":
                    this.t(a, b);
                    break;
                case "ShowGridlines":
                    this.v(a, b);
                    break;
                case "MaxValue":
                    this.z(a, b);
                    break;
                case "MinValue":
                    this.aa(a, b);
                    break;
                case "Average":
                    this.r(a, b);
                    break;
                case "Exponential":
                    this.u(a, b);
                    break;
                case "Linear":
                    this.x(a, b);
                    break;
                case "Logarithmic":
                    this.y(a, b);
                    break;
                case "NoTrends":
                    this.ab(a, b);
                    break;
                case "SeriesAvg":
                    this.ac(a, b);
                    break;
                case "ShowValueLabels":
                    this.ae(a, b);
                    break;
                case "ShowLastValueLabel":
                    this.ad(a, b);
                    break;
                case "CopyAsImage":
                    this.s(a, b);
                    return 2;
            }
            return 0;
        }
        q(a, b) {
            if (a.commandId == b) {
                let e = a.argumentsList;
                for (let d = 0; d < e.length; d++) {
                    let c = e[d];
                    if (c.argumentName == "IsChecked") {
                        return c.value;
                    }
                }
            }
            return false;
        }
        t(a, b) {
            this.ai(a, b, "ShowCrosshairs", 0, () => {
                let c = this.g.createCrosshairLayer();
                this.g.setCrosshairOnAxesEnabled(c, true);
                let d = new AutomaticSeriesRequest();
                d.a = 0;
                d.e = true;
                d.d = c;
                return d;
            });
        }
        v(a, b) {
            let c = this.q(b, "ShowGridlines");
            if (!c) {
                for (let d = 0; d < this.m.o.count; d++) {
                    let e = this.m.o._inner[d];
                    if (e.jt != null) {
                        e.jw = BrushUtil.h(0, 0, 0, 0);
                    }
                }
            }
            else {
                let f = typeCast(XamDataChart.$, a);
                if (f != null) {
                    for (let g = 0; g < f.axes.count; g++) {
                        let h = f.axes._inner[g];
                        if (this.m.d(h)) {
                            h.jw = this.m.item(h);
                        }
                        else {
                            if (h.cb) {
                                if (h.jw == null) {
                                    h.jw = f.z2;
                                    this.m.s(h, f.z2);
                                }
                                else {
                                    this.m.s(h, h.jw);
                                }
                            }
                        }
                    }
                }
            }
        }
        u(a, b) {
            if (!this.p) {
                return;
            }
            let c = this.q(b, "Exponential");
            if (c) {
                for (let d of fromEnum(a.series)) {
                    if (d.ej) {
                        if (this.p && this.k.matchesType(d)) {
                            this.k.setTrendLineType(d, 7);
                        }
                    }
                    else if (d.eu) {
                        if (this.o && this.i.matchesType(d)) {
                            this.i.setTrendLineType(d, 7);
                        }
                    }
                }
            }
        }
        x(a, b) {
            if (!this.p) {
                return;
            }
            let c = this.q(b, "Linear");
            if (c) {
                for (let d of fromEnum(a.series)) {
                    if (d.ej) {
                        if (this.p && this.k.matchesType(d)) {
                            this.k.setTrendLineType(d, 1);
                        }
                    }
                    else if (d.eu) {
                        if (this.o && this.i.matchesType(d)) {
                            this.i.setTrendLineType(d, 1);
                        }
                    }
                }
            }
        }
        y(a, b) {
            let c = this.q(b, "Logarithmic");
            if (c) {
                for (let d of fromEnum(a.series)) {
                    if (d.ej) {
                        if (this.p && this.k.matchesType(d)) {
                            this.k.setTrendLineType(d, 6);
                        }
                    }
                    else if (d.eu) {
                        if (this.o && this.i.matchesType(d)) {
                            this.i.setTrendLineType(d, 6);
                        }
                    }
                }
            }
        }
        ab(a, b) {
            let c = this.q(b, "NoTrends");
            if (c) {
                for (let d of fromEnum(a.series)) {
                    if (d.ej) {
                        if (this.p && this.k.matchesType(d)) {
                            this.k.setTrendLineType(d, 0);
                        }
                    }
                    else if (d.eu) {
                        if (this.o && this.i.matchesType(d)) {
                            this.i.setTrendLineType(d, 0);
                        }
                    }
                }
            }
        }
        ai(a, b, c, d, e) {
            let f = this.q(b, c);
            let g = a.ao(a);
            if (f && !g.e(d)) {
                if (this.n && e != null) {
                    g.b.add(e());
                }
            }
            if (!f && g.e(d)) {
                g.l(d);
            }
        }
        z(a, b) {
            this.ai(a, b, "MaxValue", 1, () => {
                let c = this.g.createValueLayer();
                this.g.setValueMode(c, 5);
                this.g.setValueAxisAnnotationEnabled(c, true);
                this.g.setBrush(c, BrushUtil.h(255, 99, 208, 0));
                let d = new AutomaticSeriesRequest();
                d.a = 1;
                d.e = true;
                d.d = c;
                return d;
            });
        }
        aa(a, b) {
            this.ai(a, b, "MinValue", 2, () => {
                let c = this.g.createValueLayer();
                this.g.setValueMode(c, 4);
                this.g.setValueAxisAnnotationEnabled(c, true);
                this.g.setBrush(c, BrushUtil.h(255, 246, 93, 80));
                let d = new AutomaticSeriesRequest();
                d.a = 2;
                d.e = true;
                d.d = c;
                return d;
            });
        }
        r(a, b) {
            this.ai(a, b, "Average", 3, () => {
                let c = this.g.createValueLayer();
                this.g.setValueMode(c, 6);
                this.g.setValueAxisAnnotationEnabled(c, true);
                this.g.setBrush(c, BrushUtil.h(255, 248, 173, 118));
                let d = new AutomaticSeriesRequest();
                d.a = 3;
                d.e = true;
                d.d = c;
                return d;
            });
        }
        ac(a, b) {
            this.ai(a, b, "SeriesAvg", 4, () => {
                let c = this.g.createValueLayer();
                this.g.setValueMode(c, 3);
                this.g.setValueAxisAnnotationEnabled(c, true);
                let d = new AutomaticSeriesRequest();
                d.a = 4;
                d.e = true;
                d.d = c;
                return d;
            });
        }
        ae(a, b) {
            this.ai(a, b, "ShowValueLabels", 5, () => {
                for (let c of fromEnum(a.series)) {
                    if (c.ej) {
                        if (this.p && this.k.matchesType(c)) {
                            let d = this.k.getMarkerType(c);
                            if (d == 1) {
                                this.k.setMarkerType(c, 13);
                            }
                        }
                    }
                }
                let e = this.g.createCalloutLayer();
                this.g.setIsAutoCalloutBehaviorEnabled(e, true);
                let f = new AutomaticSeriesRequest();
                f.a = 5;
                f.e = true;
                f.d = e;
                return f;
            });
        }
        ad(a, b) {
            this.ai(a, b, "ShowLastValueLabel", 6, () => {
                for (let c of fromEnum(a.series)) {
                    let d = c.ag();
                    if (d != null) {
                        for (let f = 0; f < d.length; f++) {
                            let e = d[f];
                            if (e.cj) {
                                e.cu = true;
                            }
                        }
                    }
                }
                let g = this.g.createFinalValueLayer();
                let h = new AutomaticSeriesRequest();
                h.a = 6;
                h.e = true;
                h.d = g;
                return h;
            });
        }
        s(a, b) {
            this.l = b;
            let c = new CaptureImageSettings();
            c.b = true;
            c.a = 0;
            a.imageCaptured = delegateCombine(a.imageCaptured, runOn(this, this.w));
            a.mv(c);
            a.al.q();
        }
        w(a, b) {
            this.l.argumentsList = [((() => {
                    let $ret = new ToolCommandArgument();
                    $ret.argumentName = "Image";
                    $ret.value = b.base64Data;
                    return $ret;
                })())];
            let c = a;
            c.imageCaptured = delegateRemove(c.imageCaptured, runOn(this, this.w));
            if (c.commandCompleted != null) {
                c.commandCompleted(this.l);
            }
        }
        af(a, b) {
            a.rh(0.05);
        }
        ag(a, b) {
            a.ri(0.05);
        }
        ah(a, b) {
            a.qq();
        }
    }
    DataChartToolbarProvider.$t = /*@__PURE__*/ markType(DataChartToolbarProvider, 'DataChartToolbarProvider', Base.$, [IDataChartToolbarProvider_$type]);
    return DataChartToolbarProvider;
})();
