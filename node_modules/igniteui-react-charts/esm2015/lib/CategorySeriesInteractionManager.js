/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, typeCast, markType } from "igniteui-react-core";
import { ICategorySeriesInteractionManager_$type } from "./ICategorySeriesInteractionManager";
import { ScalerParams } from "./ScalerParams";
import { ISortingAxis_$type } from "./ISortingAxis";
import { HighlightingInfo } from "igniteui-react-core";
import { truncate, intDivide, isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let CategorySeriesInteractionManager = /*@__PURE__*/ (() => {
    class CategorySeriesInteractionManager extends Base {
        b$c(a, b) {
            let c = a.cl.by;
            let d = a.cl.bx;
            let e = a.as();
            let f = a.getEffectiveViewport1(a.cl);
            let g = a.u1(a.cl);
            let h = -1;
            if (e != null && !c.isEmpty && !d.isEmpty) {
                let i = new ScalerParams(0, c, d, e.ch, f);
                let j = e.em(g.left, i);
                let k = e.em(g.right, i);
                let l = (b.x - c.left) / c.width;
                let m = j + (l * (k - j));
                if (e.categoryMode != 0) {
                    m -= 0.5;
                }
                h = m;
            }
            return h;
        }
        b$f(a, b) {
            let c = 0;
            if (a.fd) {
                c = a.jl(b);
                if (c == -1) {
                    return null;
                }
            }
            else if (b.x == 1 && a.dd != null) {
                c = a.dd.count - 1;
            }
            else {
                c = a.jj(b);
            }
            return c >= 0 && a.dd != null && c < a.dd.count ? a.dd.item(c) : null;
        }
        b$d(a, b) {
            let c = a.cl.by;
            let d = a.cl.bx;
            let e = a.getEffectiveViewport1(a.cl);
            if (c.isEmpty || d.isEmpty) {
                return -1;
            }
            if (isNaN_(b.x)) {
                return -1;
            }
            let f = a.as();
            if (f == null) {
                return -1;
            }
            let g = typeCast(ISortingAxis_$type, f);
            let h = a.u1(a.cl);
            let i = new ScalerParams(0, c, d, f.ch, e);
            let j = 0;
            if (f.cl) {
                let k = (b.x - c.left) / c.width;
                let l = k * h.width + h.left;
                j = f.em(l, i);
            }
            else {
                let m = f.em(h.left, i);
                let n = f.em(h.right, i);
                let o = (b.x - c.left) / c.width;
                j = m + ((n - m) * o);
            }
            let p = g.i$f(j);
            return p;
        }
        b$e(a, b, c) {
            let d = a.cl.bx;
            let e = a.cl.by;
            let f = a.as();
            let g = 0;
            if (f.cp) {
                let h = (c.y - e.top) / e.height;
                g = h * d.height + d.top;
            }
            else {
                let i = (c.x - e.left) / e.width;
                g = i * d.width + d.left;
            }
            if (f.ch) {
                let j = b.count;
                let k = 0;
                for (k = j - 1; k >= 0; k--) {
                    let l = b._inner[k];
                    let m = null;
                    if (k > 0) {
                        m = b._inner[k - 1];
                    }
                    if (l[0] <= g && m == null || m[0] >= g) {
                        if (m != null) {
                            if (Math.abs(l[0] - g) < Math.abs(m[0] - g)) {
                                return k;
                            }
                            else {
                                return k - 1;
                            }
                        }
                        else {
                            return k;
                        }
                    }
                }
                return k;
            }
            else {
                let n = b.count;
                let o = 0;
                for (o = 0; o < n; o++) {
                    let p = b._inner[o];
                    let q = null;
                    if (o < n - 1) {
                        q = b._inner[o + 1];
                    }
                    if (p[0] <= g && q == null || q[0] >= g) {
                        if (q != null) {
                            if (Math.abs(p[0] - g) < Math.abs(q[0] - g)) {
                                return o;
                            }
                            else {
                                return o + 1;
                            }
                        }
                        else {
                            return o;
                        }
                    }
                }
                return o;
            }
        }
        b$a(a, b, c, d, e, f, g, h, i) {
            if (a.dd == null) {
                return null;
            }
            if (f == 0) {
                return null;
            }
            let j = a.dd.count;
            let k = a.as();
            let l = -1;
            let m = -1;
            if (k.cn) {
                let n = this.b$e(a, b, h);
                if (c != null && n >= 0 && n < c.count) {
                    n = truncate(Math.round(c._inner[n]));
                }
                l = n;
                m = n;
            }
            else {
                let o = a.jj(h);
                l = truncate(Math.floor((intDivide(o, f)))) * f;
                m = l + (f - 1);
            }
            if (i != null && i.g == l && i.f == m) {
                return i;
            }
            let p = new HighlightingInfo();
            p.i = a;
            p.g = l;
            p.f = m;
            return p;
        }
        b$b(a, b, c, d, e, f, g, h) {
            if (a.dd == null) {
                return null;
            }
            if (d == 0) {
                return null;
            }
            if (e == null || e.count == 0) {
                return null;
            }
            let i = a.dd.count;
            let j = a.as();
            let k = -1;
            let l = -1;
            let m = -1;
            let n = -1;
            if (j.cn) {
                n = this.b$e(a, e, g);
                m = n;
                k = n;
                l = n;
            }
            else {
                let o = a.jj(g);
                m = o;
                n = truncate(Math.floor((intDivide(o, d)))) - c;
                k = n;
                l = n;
            }
            if (h != null && h.g == k && h.f == l) {
                return h;
            }
            let p = b;
            let q = p.count;
            if (p == null) {
                return null;
            }
            if (q == 0) {
                return null;
            }
            for (let r = 0; r < q; r++) {
                if (p._inner[r].al == n || p._inner[r].ak == m) {
                    let s = new HighlightingInfo();
                    s.i = a;
                    s.g = p._inner[r].ak;
                    s.f = p._inner[r].ak;
                    if (h != null && h.g == s.g && h.f == s.f) {
                        return h;
                    }
                    s.d = true;
                    return s;
                }
            }
            let t = a.up(g);
            let u = p._inner[0].ak;
            if (a.isVertical) {
                let v = e._inner[p._inner[0].al][0];
                let w = (t.y - v) * (t.y - v);
                let x;
                for (let y = 0; y < q; y++) {
                    v = e._inner[p._inner[y].al][0];
                    x = (t.y - v) * (t.y - v);
                    if (x <= w) {
                        w = x;
                        u = p._inner[y].ak;
                    }
                }
            }
            else {
                let z = e._inner[p._inner[0].al][0];
                let aa = (t.x - z) * (t.x - z);
                let ab;
                for (let ac = 0; ac < q; ac++) {
                    z = e._inner[p._inner[ac].al][0];
                    ab = (t.x - z) * (t.x - z);
                    if (ab <= aa) {
                        aa = ab;
                        u = p._inner[ac].ak;
                    }
                }
            }
            let ad = new HighlightingInfo();
            ad.i = a;
            ad.d = true;
            ad.g = u;
            ad.f = ad.g;
            if (h != null && h.g == ad.g && h.f == ad.f) {
                return h;
            }
            return ad;
        }
    }
    CategorySeriesInteractionManager.$t = /*@__PURE__*/ markType(CategorySeriesInteractionManager, 'CategorySeriesInteractionManager', Base.$, [ICategorySeriesInteractionManager_$type]);
    return CategorySeriesInteractionManager;
})();
