/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AnnotationLayer } from "./AnnotationLayer";
import { Brush } from "igniteui-react-core";
import { DependencyProperty } from "igniteui-react-core";
import { Series } from "./Series";
import { Thickness } from "igniteui-react-core";
import { Visibility_$type } from "igniteui-react-core";
import { CrosshairLayerFrame } from "./CrosshairLayerFrame";
import { List$1 } from "igniteui-react-core";
import { Axis } from "./Axis";
import { Dictionary$2 } from "igniteui-react-core";
import { Pool$1 } from "igniteui-react-core";
import { AxisAnnotation } from "./AxisAnnotation";
import { Base, Number_$type, enumGetBox, fromEnum, Point_$type, markType, markDep, runOn } from "igniteui-react-core";
import { AxisAnnotationFrameManager } from "./AxisAnnotationFrameManager";
import { Tuple$2 } from "igniteui-react-core";
import { DoubleCollection } from "igniteui-react-core";
import { DeviceUtils } from "igniteui-react-core";
import { Path } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { PropertyMetadata } from "igniteui-react-core";
import { isNaN_, truncate } from "igniteui-react-core";
import { AnnotationLayerView } from "./AnnotationLayerView";
import { Defaults } from "./Defaults";
import { TranslateTransform } from "igniteui-react-core";
import { LineGeometry } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
import { Color } from "igniteui-react-core";
/**
 * @hidden
 */
export let CrosshairLayer = /*@__PURE__*/ (() => {
    class CrosshairLayer extends AnnotationLayer {
        bb() {
            return new CrosshairLayer();
        }
        get_ec() {
            return true;
        }
        get_ea() {
            return true;
        }
        constructor() {
            super();
            this.xAxisAnnotationFormatLabel = null;
            this.yAxisAnnotationFormatLabel = null;
            this.aaz = null;
            this.ym = null;
            this.yl = null;
            let a = new CrosshairLayerFrame();
            let b = new CrosshairLayerFrame();
            let c = new CrosshairLayerFrame();
            let d = this.jt / 1000;
            this.vr = a;
            this.vq = b;
            this.vs = c;
            this.ab = CrosshairLayer.$;
        }
        ci() {
            return new CrosshairLayerView(this);
        }
        px(a) {
            super.px(a);
            this.ye = a;
        }
        yg() {
            return this.xAxisAnnotationFormatLabel != null;
        }
        yh() {
            return this.yAxisAnnotationFormatLabel != null;
        }
        get aa1() {
            return new Thickness(1, this.yp, this.yr, this.yq, this.yo);
        }
        get aa2() {
            return new Thickness(1, this.yv, this.yx, this.yw, this.yu);
        }
        w4(a, b) {
            if (this.yf == null || this.yf == a) {
                if (!this.at.c) {
                    this.qm(b);
                }
            }
        }
        w6(a, b) {
            super.w6(a, b);
            let c = a;
            let d = this.yk;
            let e = this.yj;
            c.af.clear();
            c.ag.clear();
            c.ae.clear();
            c.ah.clear();
            AxisAnnotationFrameManager.b(c);
            if (this.vx(this.yf)) {
                this.zw(this.yf, c, d, e);
            }
            else {
                for (let f of fromEnum(this.c1.series)) {
                    if (this.vx(f)) {
                        this.zw(f, c, d, e);
                    }
                    if (f.isStacked) {
                        f.o0((g) => {
                            if (this.vx(g)) {
                                this.zw(g, c, d, e);
                            }
                            if (g.d2) {
                                g.oy((h) => {
                                    if (this.vx(h)) {
                                        this.zw(h, c, d, e);
                                    }
                                    return true;
                                });
                            }
                            return true;
                        });
                    }
                    if (f.d2) {
                        f.oy((g) => {
                            if (this.vx(g)) {
                                this.zw(g, c, d, e);
                            }
                            return true;
                        });
                    }
                }
            }
        }
        vx(a) {
            if (!super.vx(a)) {
                return false;
            }
            if (this.y5 != null) {
                if (a.ew) {
                    let b = a.mg();
                    if (!Base.equalsStatic(this.y5, b)) {
                        return false;
                    }
                }
                else {
                    if (!Base.equalsStatic(this.y5, a.name)) {
                        return false;
                    }
                }
            }
            let c = this.wz(a);
            if (!c.c) {
                return false;
            }
            return true;
        }
        pl() {
            super.pl();
            if (!this.at.c && !this.dr()) {
                return;
            }
            if (this.dr()) {
                this.zx(this.vs, false);
            }
            else {
                this.zx(this.vq, false);
            }
        }
        vh() {
            return 1;
        }
        v4() {
            return 0.1;
        }
        v7() {
            return -0.4;
        }
        v6() {
            return 0.5;
        }
        x3() {
            return this.ve == 3 ? this.aa0() : null;
        }
        x4() {
            return this.vf == 3 ? this.aa0() : null;
        }
        aa0() {
            if (this.aaz == null) {
                this.aaz = new DoubleCollection();
                this.aaz.add(DeviceUtils.g(5));
                this.aaz.add(DeviceUtils.g(5));
            }
            return this.aaz;
        }
        zw(a, b, c, d) {
            let e = this.wz(a);
            if (!e.c) {
                return;
            }
            let f = e.d;
            f = a.uu(f, c, d);
            let g = false;
            let h = this.tw;
            if (h == null) {
                h = this.t2;
            }
            if (h == null) {
                h = a.tw;
                g = true;
            }
            let i = false;
            let j = this.aat;
            if (j == null) {
                if (this.t2 != null) {
                    j = this.t2;
                }
                else {
                    j = a.tw;
                    i = true;
                }
            }
            let k = false;
            let l = this.aaw;
            if (l == null) {
                if (this.t2 != null) {
                    l = this.t2;
                }
                else {
                    l = a.tw;
                    k = true;
                }
            }
            let m = h;
            let n = h;
            let o = j;
            let p = l;
            if (this.aar != null) {
                m = this.aar;
            }
            else if (g) {
                switch (this.ve) {
                    case 0:
                    case 1:
                        m = this.ye.ce(m, this.v1);
                        break;
                    case 2:
                        m = this.ye.cg(m, this.v1);
                        break;
                    case 4:
                        m = this.ye.cf(m, this.v1);
                        break;
                }
            }
            if (this.aas != null) {
                n = this.aas;
            }
            else if (g) {
                switch (this.vf) {
                    case 0:
                    case 1:
                        n = this.ye.ce(n, this.v3);
                        break;
                    case 2:
                        n = this.ye.cg(n, this.v3);
                        break;
                    case 4:
                        n = this.ye.cf(n, this.v3);
                        break;
                }
            }
            if (i) {
                switch (this.vf) {
                    case 1:
                        o = this.ye.ce(o, this.v3);
                        break;
                    case 2:
                        o = this.ye.cg(o, this.v3);
                        break;
                }
            }
            if (k) {
                switch (this.ve) {
                    case 1:
                        p = this.ye.ce(p, this.v1);
                        break;
                    case 2:
                        p = this.ye.cg(p, this.v1);
                        break;
                }
            }
            b.ae.add(m);
            b.ah.add(n);
            b.af.add(f.y);
            b.ag.add(f.x);
            if (this.yi && !isNaN_(f.y)) {
                AxisAnnotationFrameManager.c(b, f, a, this.c1, this.getEffectiveViewport(), h, o, this.yn, this.aav, this.aau, this.aa1, this.ys, p, this.yt, this.aay, this.aax, this.aa2, this.yy, this.aa4 == 0, this.aa3 == 0);
            }
        }
        zx(a, b) {
            let c = false;
            if (this.yl == null) {
                c = true;
                this.ym = new List$1(Axis.$, 0);
                this.yl = new Dictionary$2(Axis.$, Pool$1.$.specialize(AxisAnnotation.$), 0);
            }
            AxisAnnotationFrameManager.d(this, a, c, this.yl, this.ym, b, this.yz, this.y0, this.xAxisAnnotationFormatLabel, this.yAxisAnnotationFormatLabel);
        }
        zv(a, b, c, d, e) {
            let f = a.item(b);
            b++;
            if (e) {
                f._stroke = d.ah._inner[c];
                f._fill = d.ah._inner[c];
            }
            else {
                f._stroke = d.ae._inner[c];
                f._fill = d.ae._inner[c];
            }
            f.ad = this.hv;
            f.ai = e ? this.x2 : this.x1;
            f.am = this.un;
            f.al = this.um;
            f.ak = this.um;
            f.aj = this.ul;
            f.ac = this.ix;
            return new Tuple$2(Path.$, Number_$type, f, b);
        }
        w9(a, b) {
            super.w9(a, b);
            let c = this.ye.b8;
            let d = a;
            let e = d.af.count;
            let f = 0;
            let g = b.bx.left;
            let h = b.bx.right;
            let i = b.bx.top;
            let j = b.bx.bottom;
            let k = this.aa4 == 0;
            let l = this.aa3 == 0;
            for (let m = 0; m < e; m++) {
                let n = Math.floor(d.af._inner[m]);
                let o = Math.floor(d.ag._inner[m]);
                let p = null;
                if (k) {
                    if (isNaN_(n)) {
                        continue;
                    }
                    let q = this.zv(c, f, m, d, true);
                    p = q.c;
                    f = q.d;
                    let r = new PathGeometry();
                    let s = new PathFigure();
                    s._startPoint = { $type: Point_$type, x: o, y: i };
                    let t = new LineSegment(1);
                    t.c = { $type: Point_$type, x: o, y: j };
                    s._segments.add(t);
                    r.c.add(s);
                    p.an = r;
                }
                if (l) {
                    if (isNaN_(n)) {
                        continue;
                    }
                    let u = this.zv(c, f, m, d, false);
                    p = u.c;
                    f = u.d;
                    let v = new PathGeometry();
                    let w = new PathFigure();
                    w._startPoint = { $type: Point_$type, x: g, y: n };
                    let x = new LineSegment(1);
                    x.c = { $type: Point_$type, x: h, y: n };
                    w._segments.add(x);
                    v.c.add(w);
                    p.an = v;
                }
            }
            c.count = f;
            if (this.dr()) {
                this.zx(this.vs, true);
            }
            else {
                this.zx(this.vq, false);
            }
        }
        fu() {
            return true;
        }
        p5(a, b, c, d) {
            super.p5(a, b, c, d);
            switch (b) {
                case "SeriesViewer":
                    if (d == null) {
                        if (this.yl != null && this.yl.count > 0) {
                            let e;
                            if (this.dr()) {
                                e = this.vs;
                            }
                            else {
                                e = this.vq;
                            }
                            AxisAnnotationFrameManager.b(e);
                            AxisAnnotationFrameManager.d(this, e, true, this.yl, this.ym, true, this.yz, this.y0, this.xAxisAnnotationFormatLabel, this.yAxisAnnotationFormatLabel);
                        }
                    }
                    break;
                case CrosshairLayer.$$p[1]:
                    this.qm(true);
                    break;
                case CrosshairLayer.$$p[8]:
                    this.qm(true);
                    break;
                case CrosshairLayer.$$p[4]:
                case CrosshairLayer.$$p[5]:
                    this.qm(true);
                    break;
                case CrosshairLayer.$$p[2]:
                case CrosshairLayer.$$p[10]:
                case CrosshairLayer.$$p[9]:
                case CrosshairLayer.$$p[12]:
                case CrosshairLayer.$$p[14]:
                case CrosshairLayer.$$p[16]:
                case CrosshairLayer.$$p[15]:
                case CrosshairLayer.$$p[13]:
                case CrosshairLayer.$$p[17]:
                case CrosshairLayer.$$p[18]:
                case CrosshairLayer.$$p[20]:
                case CrosshairLayer.$$p[22]:
                case CrosshairLayer.$$p[24]:
                case CrosshairLayer.$$p[26]:
                case CrosshairLayer.$$p[25]:
                case CrosshairLayer.$$p[23]:
                case CrosshairLayer.$$p[27]:
                case CrosshairLayer.$$p[28]:
                case CrosshairLayer.$$p[0]:
                case CrosshairLayer.$$p[7]:
                case CrosshairLayer.$$p[6]:
                    this.qm(true);
                    break;
            }
        }
    }
    CrosshairLayer.$t = /*@__PURE__*/ markType(CrosshairLayer, 'CrosshairLayer', AnnotationLayer.$);
    CrosshairLayer.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, CrosshairLayer, 'raisePropertyChanged', ['HorizontalLineStroke:aar:zy', [Brush.$, null], 'HorizontalLineVisibility:aa3:zz', [Visibility_$type, /*@__PURE__*/ enumGetBox(Visibility_$type, 0)], 'IsAxisAnnotationEnabled:yi:z0', [0, false], 'SkipUnknownValues:yj:z1', [0, true], 'TargetSeriesName:y5:z2', [2, null], 'TargetSeries:yf:z3', [Series.$, null], 'UseInterpolation:yk:z4', [0, true], 'VerticalLineStroke:aas:z5', [Brush.$, null], 'VerticalLineVisibility:aa4:z6', [Visibility_$type, /*@__PURE__*/ enumGetBox(Visibility_$type, 0)], 'XAxisAnnotationBackgroundCornerRadius:yn:z7', [1, /*@__PURE__*/ DeviceUtils.g(3)], 'XAxisAnnotationBackground:aat:z8', [Brush.$, null], 'XAxisAnnotationInterpolatedValuePrecision:yz:z9', [1, -1], 'XAxisAnnotationOutline:aau:aaa', [Brush.$, null], 'XAxisAnnotationPaddingBottom:yo:aab', [1, NaN], 'XAxisAnnotationPaddingLeft:yp:aac', [1, NaN], 'XAxisAnnotationPaddingRight:yq:aad', [1, NaN], 'XAxisAnnotationPaddingTop:yr:aae', [1, NaN], 'XAxisAnnotationStrokeThickness:ys:aaf', [1, NaN], 'XAxisAnnotationTextColor:aav:aag', [Brush.$, null], 'YAxisAnnotationBackgroundCornerRadius:yt:aah', [1, /*@__PURE__*/ DeviceUtils.g(3)], 'YAxisAnnotationBackground:aaw:aai', [Brush.$, null], 'YAxisAnnotationInterpolatedValuePrecision:y0:aaj', [1, -1], 'YAxisAnnotationOutline:aax:aak', [Brush.$, null], 'YAxisAnnotationPaddingBottom:yu:aal', [1, NaN], 'YAxisAnnotationPaddingLeft:yv:aam', [1, NaN], 'YAxisAnnotationPaddingRight:yw:aan', [1, NaN], 'YAxisAnnotationPaddingTop:yx:aao', [1, NaN], 'YAxisAnnotationStrokeThickness:yy:aap', [1, NaN], 'YAxisAnnotationTextColor:aay:aaq', [Brush.$, null]]);
    return CrosshairLayer;
})();
/**
 * @hidden
 */
export let CrosshairLayerView = /*@__PURE__*/ (() => {
    class CrosshairLayerView extends AnnotationLayerView {
        constructor(a) {
            super(a);
            this.b7 = null;
            this.b8 = null;
            this.b9 = null;
            this.b7 = a;
            this.b9 = new List$1(Path.$, 0);
        }
        au() {
            super.au();
            this.b8 = ((() => {
                let $ret = new Pool$1(Path.$);
                $ret.create = runOn(this, this.ch);
                $ret.activate = runOn(this, this.ca);
                $ret.disactivate = runOn(this, this.cc);
                $ret.destroy = runOn(this, this.cb);
                return $ret;
            })());
            this.b7.i5 = Defaults.j;
        }
        ch() {
            let a = new Path();
            a.j = new TranslateTransform();
            this.b9.add(a);
            return a;
        }
        ca(a) {
            a._visibility = 0;
        }
        cc(a) {
            a._visibility = 1;
        }
        cb(a) {
            this.b9.remove(a);
        }
        cd(a, b, c, d) {
            if (a.an == null || a.an.c.x != d || a.an.d.x != c) {
                let e = ((() => {
                    let $ret = new LineGeometry();
                    $ret.d = { $type: Point_$type, x: c, y: b };
                    $ret.c = { $type: Point_$type, x: d, y: b };
                    return $ret;
                })());
                a.an = e;
            }
        }
        ce(a, b) {
            if (a == null) {
                return a;
            }
            return BrushUtil.m(a, b);
        }
        cg(a, b) {
            if (a == null) {
                return a;
            }
            return BrushUtil.o(a, b);
        }
        cf(a, b) {
            if (a == null) {
                return a;
            }
            let c = new Brush();
            c.color = Color.u(truncate((a.color.l * b)), a.color.o, a.color.n, a.color.m);
            return c;
        }
        a8(a, b) {
            super.a8(a, b);
            if (a.d && !b) {
                for (let c = 0; c < this.b9.count; c++) {
                    let d = this.b9._inner[c];
                    if (d._visibility == 0) {
                        a.t(d);
                    }
                }
            }
        }
        an(a) {
            super.an(a);
            for (let b = 0; b < this.b9.count; b++) {
                this.e.a4.exportPathData(a, this.b9._inner[b], "crosshairLine", ["Main", "Crosshair"]);
            }
        }
    }
    CrosshairLayerView.$t = /*@__PURE__*/ markType(CrosshairLayerView, 'CrosshairLayerView', AnnotationLayerView.$);
    return CrosshairLayerView;
})();
