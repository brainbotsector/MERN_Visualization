/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AnnotationLayer } from "./AnnotationLayer";
import { Axis } from "./Axis";
import { DependencyProperty } from "igniteui-react-core";
import { CategoryTooltipLayerPosition_$type } from "./CategoryTooltipLayerPosition";
import { Series } from "./Series";
import { CategoryToolTipLayerFrame } from "./CategoryToolTipLayerFrame";
import { Base, enumGetBox, typeCast, fromEnum, Point_$type, markType, markDep, String_$type } from "igniteui-react-core";
import { CategoryTooltipSeriesInfo } from "./CategoryTooltipSeriesInfo";
import { XamDataChart } from "./XamDataChart";
import { List$1 } from "igniteui-react-core";
import { DataContext } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
import { DeviceUtils } from "igniteui-react-core";
import { PropertyMetadata } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
import { AnnotationLayerView } from "./AnnotationLayerView";
import { PointerTooltip } from "./PointerTooltip";
/**
 * @hidden
 */
export let CategoryToolTipLayer = /*@__PURE__*/ (() => {
    class CategoryToolTipLayer extends AnnotationLayer {
        bb() {
            return new CategoryToolTipLayer();
        }
        get_ec() {
            return true;
        }
        constructor() {
            super();
            let a = new CategoryToolTipLayerFrame();
            let b = new CategoryToolTipLayerFrame();
            let c = new CategoryToolTipLayerFrame();
            this.vr = a;
            this.vq = b;
            this.vs = c;
            this.ab = CategoryToolTipLayer.$;
        }
        ci() {
            return new CategoryToolTipLayerView(this);
        }
        px(a) {
            super.px(a);
            this.ye = a;
        }
        get_en() {
            return true;
        }
        p5(a, b, c, d) {
            super.p5(a, b, c, d);
            switch (b) {
                case CategoryToolTipLayer.$$p[0]:
                    this.qm(true);
                    break;
                case CategoryToolTipLayer.$$p[2]:
                    this.qm(true);
                    break;
                case CategoryToolTipLayer.$$p[1]:
                    this.qm(true);
                    break;
                case "SeriesViewer":
                    this.ye.ci();
                    break;
            }
        }
        w3(a, b) {
            if (this.yc == a) {
                if (!this.at.c) {
                    this.qm(b);
                }
            }
        }
        w4(a, b) {
            if (!this.at.c) {
                this.qm(b);
            }
        }
        w6(a, b) {
            super.w6(a, b);
            let c = a;
            let d = this.yg;
            c.l = NaN;
            c.k = NaN;
            c.g = NaN;
            c.h = NaN;
            c.k = NaN;
            c.l = NaN;
            if (isNaN_(this.x9.x) && isNaN_(this.x9.y)) {
                this.ye.cg(this.ye.cd());
                return;
            }
            if (this.yc != null) {
                let e = this.yc;
                if (e == null || !e.cb || e.b9) {
                    return;
                }
                if (!e.co()) {
                    return;
                }
                let f = e;
                let g = this.yf(f.de, d);
                this.yl(g, c, d);
            }
            else {
                if (typeCast(XamDataChart.$, this.c1) !== null) {
                    let h = this.c1;
                    let i = true;
                    let j = false;
                    let k = new List$1(Series.$, 0);
                    for (let l of fromEnum(h.axes)) {
                        if (l.cb && !l.b9) {
                            if (!l.co()) {
                                continue;
                            }
                            if (i) {
                                i = false;
                                j = l.cp;
                            }
                            else {
                                if (l.cp != j) {
                                    continue;
                                }
                            }
                            for (let m of fromEnum(l.de)) {
                                k.add(m);
                            }
                        }
                    }
                    let n = this.yf(k, d);
                    this.yl(n, c, d);
                }
            }
        }
        yf(a, b) {
            let c = 1.7976931348623157E+308;
            let d = -1.7976931348623157E+308;
            let e = new List$1(DataContext.$, 0);
            let f = new List$1(Base.$, 0);
            let g = false;
            let h = true;
            for (let i = 0; i < a.count; i++) {
                let j = a.item(i);
                if (!j.er && !j.ej) {
                    continue;
                }
                if (j.isStacked) {
                    continue;
                }
                let k = j;
                if (!k.categoryAxis.co()) {
                    continue;
                }
                if (h) {
                    g = j.isVertical;
                }
                else {
                    if (g != j.isVertical) {
                        continue;
                    }
                }
                let l = this.wz(j);
                if (!l.c) {
                    continue;
                }
                let m = j.uu(l.d, b, false);
                if (g) {
                    if (!isNaN_(m.y)) {
                        c = Math.min(c, m.y);
                        d = Math.max(d, m.y);
                    }
                }
                else {
                    if (!isNaN_(m.x)) {
                        c = Math.min(c, m.x);
                        d = Math.max(d, m.x);
                    }
                }
                let n = this.yh(j);
                if (n == null) {
                    continue;
                }
                let o = null;
                let p = j.j2(this.x9);
                if (j.eo && p != null) {
                    o = j.av(p);
                }
                else {
                    o = new DataContext();
                    o.item = p;
                    o.series = j;
                }
                e.add(o);
                f.add1(n);
            }
            let q = 0;
            let r = 0;
            if (g) {
                r = (c + d) / 2;
                q = this.u9.right;
                if (this.yd == 2 || this.yd == 1) {
                    q = this.u9.left;
                }
                if (r < 0 || r > this.u9.bottom) {
                    r = NaN;
                }
            }
            else {
                q = (c + d) / 2;
                r = this.u9.top;
                if (this.yd == 2 || this.yd == 1) {
                    r = this.u9.bottom;
                }
                if (q < 0 || q > this.u9.right) {
                    q = NaN;
                }
            }
            let s = new CategoryTooltipSeriesInfo();
            s.c = { $type: Point_$type, x: q, y: r };
            s.a = e;
            s.b = f;
            return s;
        }
        o3() {
            this.x9 = { $type: Point_$type, x: NaN, y: NaN };
            this.cl.ar();
        }
        yl(a, b, c) {
            let d = a.c;
            let e = a.a;
            let f = a.b;
            d = this.ye.cj(d);
            let g = 0;
            let h = this.cl.bx;
            let i = this.ye.cd();
            this.ye.cf();
            let j = false;
            if (e.count == 0) {
                this.cl.ar();
                return;
            }
            let k = false;
            for (let l = 0; l < e.count; l++) {
                let m = e._inner[l].series;
                j = m.isVertical;
                let n = e._inner[l];
                let o = f._inner[l];
                if (this.ye.ca(m, o, n)) {
                    k = true;
                }
                g++;
            }
            if (!k) {
                this.ye.cg(i);
                return;
            }
            let p = this.ye.ck(i);
            let q = 0;
            let r = 0;
            let s = 0;
            let t = 0;
            let u = false;
            let v = false;
            let w = this.yd;
            if (w == 2 || w == 3) {
                v = true;
            }
            if (w == 2 || w == 1) {
                u = true;
            }
            let x = this.ye.cl();
            if (j) {
                if (!u && !v && d.x + (p.width + DeviceUtils.g(10)) > x.width) {
                    v = true;
                }
                if (u && !v && d.x - (p.width + DeviceUtils.g(10)) < 0) {
                    v = true;
                }
            }
            else {
                if (!u && !v && d.y - (p.height + 10) < 0) {
                    v = true;
                }
                if (u && !v && d.y + (p.height + 10) > x.height) {
                    v = true;
                }
            }
            let y = DeviceUtils.g(10);
            let z = DeviceUtils.g(5);
            if (!u) {
                if (!j) {
                    z = p.height + y;
                }
                if (v) {
                    if (j) {
                        z = z + p.width + y;
                    }
                    else {
                        z = 0;
                    }
                }
            }
            else {
                if (j) {
                    z = p.width + y;
                    if (v) {
                        z = 0;
                    }
                }
                else {
                    z = DeviceUtils.g(5);
                    if (v) {
                        z = z + p.height + y;
                    }
                }
            }
            if (j) {
                r = 0 - (y + DeviceUtils.g(5));
                if (u) {
                    r = (r * -1) + p.width;
                }
                q = p.height / 2;
                t = d.y - p.height / 2;
                s = d.x - z;
            }
            else {
                q = p.height + DeviceUtils.g(10) + DeviceUtils.g(5);
                if (u) {
                    q = 0 - (y + DeviceUtils.g(5));
                }
                r = p.width / 2;
                s = d.x - p.width / 2;
                t = d.y - z;
            }
            if (j) {
                if (t < 0) {
                    q -= 0 - t;
                    t = 0;
                }
                if (t + p.height > x.height) {
                    q += (t + p.height) - x.height;
                    t = x.height - p.height;
                }
            }
            else {
                if (s < 0) {
                    r -= 0 - s;
                    s = 0;
                }
                if (s + p.width > x.width) {
                    r += (s + p.width) - x.width;
                    s = x.width - p.width;
                }
            }
            b.k = s;
            b.l = t;
            b.g = r;
            b.h = q;
            b.j = p.width;
            b.i = p.height;
        }
        yh(a) {
            return a.toolTip;
        }
        w9(a, b) {
            super.w9(a, b);
            let c = a;
            let d = b.bx.left;
            let e = b.bx.right;
            let f = b.bx.top;
            let g = b.bx.bottom;
            let h = this.ye.cd();
            if (isNaN_(c.k) || isNaN_(c.l) || isNaN_(c.g) || isNaN_(c.h)) {
                this.ye.cg(h);
                return;
            }
            let i = c.k;
            let j = c.l;
            let k = c.g;
            let l = c.h;
            if (h != null) {
                this.ye.ch(h, i, j, k, l);
            }
        }
        fu() {
            return true;
        }
    }
    CategoryToolTipLayer.$t = /*@__PURE__*/ markType(CategoryToolTipLayer, 'CategoryToolTipLayer', AnnotationLayer.$);
    CategoryToolTipLayer.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, CategoryToolTipLayer, 'raisePropertyChanged', ['TargetAxis:yc:ym', [Axis.$, null], 'ToolTipPosition:yd:yn', [CategoryTooltipLayerPosition_$type, /*@__PURE__*/ enumGetBox(CategoryTooltipLayerPosition_$type, 0)], 'UseInterpolation:yg:yo', [0, false]]);
    return CategoryToolTipLayer;
})();
/**
 * @hidden
 */
export let CategoryToolTipLayerView = /*@__PURE__*/ (() => {
    class CategoryToolTipLayerView extends AnnotationLayerView {
        constructor(a) {
            super(a);
            this.b7 = null;
            this.b8 = null;
            this._tooltips = null;
            this.cb = null;
            this.b9 = false;
            this._htmlTest = null;
            this.b7 = a;
            this.htmlTest = /^[^<]*(<[\w\W]+>)[^>]*$/;
        }
        cd() {
            if (this.b8 == null) {
                this.b8 = new PointerTooltip();
                this.b8.bw(this.e.jf);
                this.b8.ap = this.e.c1.c8.k;
                this._tooltips = this.e.jf.createElement("div");
                this.cb = this.e.jf.createElement("div");
                this.b8._visibility = 0;
            }
            return this.b8;
        }
        au() {
            super.au();
            if (this.b8 != null) {
                this.b8._visibility = 1;
            }
        }
        ak() {
            super.ak();
            if (this.b8 != null) {
                this.b8.br();
                this.b8 = null;
            }
        }
        get htmlTest() {
            return this._htmlTest;
        }
        set htmlTest(a) {
            this._htmlTest = a;
        }
        ca(a, b, c) {
            if (a.kd == "default") {
                a.kd = a.cl.getDefaultTooltipTemplate();
            }
            let template_ = a.kd;
            let context_ = c;
            if (a.toolTip == null) {
                return false;
            }
            let tooltip_ = a.toolTip;
            if ((tooltip_.updateToolTip)) {
                tooltip_._inPointer = true;
                tooltip_.updateToolTip(context_, true);
                tooltip_.setStyleProperty('position', 'relative');
                tooltip_.setStyleProperty('left', '');
                tooltip_.setStyleProperty('top', '');
                tooltip_.remove();
            }
            this._tooltips.append(a.toolTip);
            return true;
        }
        ck(a) {
            let b = a;
            b.content = this._tooltips;
            let c = new Size(1, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
            b.cy = 1;
            let d = b.cx(new Size(1, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY));
            b.cy = 0;
            return d;
        }
        cj(a) {
            let b = 0;
            let c = 0;
            if (this.e.c1 != null) {
                let d = this.e.c1.va();
                b += d.x;
                c += d.y;
            }
            return { $type: Point_$type, x: b + a.x, y: c + a.y };
        }
        ch(a, b, c, d, e) {
            let f = a;
            let g = f.content;
            f.cs = { $type: Point_$type, x: d, y: e };
            f._visibility = 0;
            f.n = b;
            f.o = c;
        }
        cl() {
            let a = (window.innerWidth);
            let b = (window.innerHeight);
            return new Size(1, a, b);
        }
        cg(a) {
            this._tooltips.removeChildren();
            this.cb.removeChildren();
            this.b8._visibility = 1;
        }
        cf() {
            if (this._tooltips != null) {
                this._tooltips.removeChildren();
            }
        }
        ci() {
        }
        a8(a, b) {
            super.a8(a, b);
            if (b) {
                return;
            }
            let c = null;
            if (this.e.c1 != null) {
                c = this.e.c1.c8.j.i();
            }
            let d = 0;
            let e = 0;
            let f = this.e.c1;
            if (f != null) {
                let g = f.c8.j.b8();
                d += g.x;
                e += g.y;
            }
            if (this.b8 != null) {
                this.b8.aq = c;
                this.b8.by(this.b8.n, this.b8.o);
            }
        }
        an(a) {
            super.an(a);
            let b = this.b8;
            let c = 0;
            let d = 0;
            if (this.e.c1 != null) {
                let e = this.e.c1.va();
                c += e.x;
                d += e.y;
            }
            let f = b.a5();
            let g = b.n - c;
            let h = b.o - d;
            let i = new List$1(String_$type, 0);
            let j = this._tooltips.getChildCount();
            for (let k = 0; k < j; k++) {
                let indexliteral_ = k.toString();
                let l = this._tooltips.getChildAt(k).getText();
                let m = l.toString();
                i.add(m);
            }
            this.e.a4.addPointerTooltipData(a, f, g, h, i);
        }
    }
    CategoryToolTipLayerView.$t = /*@__PURE__*/ markType(CategoryToolTipLayerView, 'CategoryToolTipLayerView', AnnotationLayerView.$);
    return CategoryToolTipLayerView;
})();
